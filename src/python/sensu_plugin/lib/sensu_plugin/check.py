#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pylint: disable=no-member
"""This is the base class for all Sensu Checks to build from."""


import re
from dataclasses import dataclass
from typing import List

from sensu_plugin.check_result import CheckResultMetadata
from sensu_plugin.plugin import SensuPlugin
from sensu_plugin.threshold import Threshold, ThresholdResult


@dataclass
class SensuPluginCheck(SensuPlugin):
    """Class that inherits from SensuPlugin."""

    thresholds: List[Threshold]

    def __init__(self, thresholds: list[Threshold] = None, autorun: bool = True):
        """Initialise the SensuPluginCheck class.

        Args:
            thresholds (list[Threshold]): List of thresholds to be used by the plugin
            autorun (bool): Whether the plugin should be run automatically. This can
                be useful for automated testing

        Returns:
            SensuPluginCheck: Instance of the SensuPluginCheck class
        """
        self.thresholds = thresholds or []

        SensuPlugin.__init__(self, autorun)

    def check_name(self, name: str = None) -> str:
        """Check the plugin name and set it accordingly.

        Use name if specified, class name if not set.

        Args:
            name (str): Name of the plugin

        Returns:
            str: Name of the plugin
        """
        if name:
            self.plugin_info["check_name"] = name

        if self.plugin_info["check_name"] is not None:
            return self.plugin_info["check_name"]

        return self.__class__.__name__

    def message(self, *m: str) -> None:
        """
        Set the message to be output by the plugin.

        Args:
            m (str): Message to be output by the plugin
        """
        self.plugin_info["message"] = m

    def output(  # noqa: PLR913
        self,
        args: List[str] = None,
        alert_key: str = None,
        severity: str = None,
        team: str = None,
        source: str = None,
    ) -> None:
        """Generate and output the result of the plugin.

        Correctly format the output into the format that Sensu expects.

        This function is called for every line of output generated by the check (but not metrics).

        A pipe is used as a delimiter between the format required by Sensu, and any additional metadata
        that can be used by handlers. e.g the alert key, severity, team and alert source.

        There is no return value from this function, as it prints the output directly to stdout.

        Args:
            args (list): List of lines to be output by the plugin. Normally this will contain
                a single string
            alert_key (str): Alert key to be used by check handlers
            severity (str): Severity of the alert (Minor, Major, Critical). Used when you need more than just WARN and CRIT
            team (str): Team responsible for the alert
            source (str): Source of the alert. If the alert is being generated on a proxy
                host, this should be the hostname of the host that generated the alert
        """
        msg = ""
        # If there's more than 1 string passed in, then we will join them together
        # This will ensure that stack traces for example only output a single line
        if args is not None and not (args[0] is None and len(args) == 1):
            msg = f": {' '.join(str(message) for message in args)}"
        else:
            msg = self.plugin_info["message"]

        # Default to OK
        self.plugin_info["status"] = "OK"
        if severity and not re.match(r"^Minor", severity, re.IGNORECASE):
            self.plugin_info["status"] = "CRITICAL"
        elif severity:
            self.plugin_info["status"] = "WARN"

        alert_key = f"KEY:{alert_key} " if alert_key else ""
        severity_msg = f"SEV:{severity} " if severity else ""
        team_msg = f"TEAM:{team} " if team else ""
        source_msg = f"SOURCE:{source} " if source else ""

        end_text = (
            f" | {alert_key}{severity_msg}{team_msg}{source_msg}"
            if (alert_key or severity_msg or team_msg or source_msg)
            else ""
        )
        output_text = f"{self.check_name()} {self.plugin_info['status']}{msg}{end_text}"

        print(output_text)

    def return_final_output(self, rc: int, result_message: str):
        """Handle the final output message of the plugin and call the exit function with the correct return code.

        This function is called once at the end of the plugin execution.

        The ok, warning, critical functions are dynamically added to the class by the SensuPlugin (__make_dynamic)

        Args:
            rc (int): Return code to be used by the plugin
            result_message (str): Message to be output by the plugin
        """
        if rc == 0:
            self.ok(result_message, exit=True)
        elif rc == 1:
            self.warning(result_message, exit=True)
        elif rc == 2:
            self.critical(result_message, exit=True)
        else:
            self.unknown("Unknown state returned", exit=True)

    def process_value(  # noqa: PLR913
        self,
        alert_id: str,
        current_value: str | int,
        ok_message: str,
        alert_message: str = None,
        warn_message: str = None,
        crit_message: str = None,
        alert_type: str = None,
    ) -> None:
        """Process threshold values and return the appropriate message and exit code.

        This function does the body of the work for a SensuPluginCheck. It takes the current value
        and compares it against the thresholds defined in the thresholds list.

        If the current value is outside of the thresholds, then the appropriate message is returned
        and the appropriate exit code is set.

        Templated messages:

        The templated messages are used to allow the user to define the output for each threshold as
        it is checked. The templated values are surrounded by double colons (::) and are replaced with
        the appropriate values when the message is returned.

        The following templated values are available:
            THRESHOLD: The threshold value that was breached
            ALERT_TYPE: The type of alert that was breached (e.g. %, cores, MB)
            PERIOD: The period of time that the threshold breached before triggering

        Args:
            alert_id (str): The ID of the alert. This is used to identify the alert in the thresholds list
            current_value (str | int): The current value to be checked against the thresholds
            ok_message (str): The message to be returned if the current value is within the thresholds
            alert_message (str): The default templated message to return when the threshold is breached. This is used if no warn_message or crit_message is passed
            warn_message (str): The templated message to return when the warn threshold is breached
            crit_message (str): The templated message to return when the crit threshold is breached
        """
        # This will be the final object we return. Give it a default of 0 (OK) for now

        ok_message, alert_message, warn_message, crit_message = self._format_messages(
            ok_message, alert_message, warn_message, crit_message
        )

        self.logger.debug(
            f"Checking thresholds for key: {alert_id} - With current value of {current_value}"
        )

        # Look for a threshold with a matching ID
        matching_thresholds = self.get_thresholds(alert_id, alert_type)

        # Create a CheckResultMetadata object to store the alert messages, alert id and check name
        check_result_metadata = CheckResultMetadata(
            ok_message,
            warn_message,
            crit_message,
            self.check_name(),
            alert_id,
            alert_type,
            self.SENSU_CACHE_DIR,
        )

        result = None

        # Evaluate each threshold and aggregate the results
        threshold_id = 1
        for matching_threshold in matching_thresholds:
            self.logger.debug(f"Using threshold: {matching_threshold}")
            threshold_result = matching_threshold.evaluate_threshold(
                threshold_id,
                current_value,
                check_result_metadata,
            )
            threshold_id += 1

            # If result is none, then use threshold_result, otherwise, check the threshold_result rc value, if it's higher, then append the result_messages to the existing result, and set the rc to that value
            if result is None:
                result = threshold_result
            else:
                if threshold_result["rc"] > result["rc"]:
                    result["rc"] = threshold_result["rc"]

                result["result_messages"] += threshold_result["result_messages"]

            # Loop through each threshold
            # threshold_id = 1
            # for matching_threshold in matching_thresholds:
            # logging.debug(f"Using threshold: {matching_threshold}")

            # # If the threshold is set to ignore, then just return here with no output
            # if matching_threshold.ignore:
            #     logging.debug("Skipping due to ignore")
            #     return None

            # # Now do the actual threshold checking
            # status_file_dir = f"{self.SENSU_CACHE_DIR}/alert_status_cache"

            # # Load the alert cache, if one exists
            # self._load_alert_cache(matching_threshold, threshold_id, status_file_dir)

            # # Check whether we're within an exclusion time period which would prevent us from alerting
            # exclusion_active = self._is_in_exclusion_time(matching_threshold)

            # thresholds = ["crit", "warn"]
            # has_output = False
            # rc = 0

            # check_name = re.sub(r"[^a-zA-Z0-9\._]", "", self.check_name())
            # state_file = f"{status_file_dir}/{check_name}_threshold_{threshold_id}"

            # # Loop through the critical and warning thresholds
            # if not exclusion_active:
            #     for threshold in thresholds:
            #         (threshold_limit, delta, message, severity) = (None,) * 4

            #         ok_message = ok_message.format(
            #             THRESHOLD=threshold_limit,
            #             ALERT_TYPE=alert_type,
            #         )

            #         if threshold == "crit" and matching_threshold.crit_threshold:
            #             threshold_limit = float(matching_threshold.crit_threshold)
            #             if matching_threshold.crit_time_seconds:
            #                 delta = dt.timedelta(
            #                     seconds=matching_threshold.crit_time_seconds
            #                 )
            #             message = crit_message
            #             severity = matching_threshold.next_severity()
            #             alert_time = matching_threshold.crit_time_seconds
            #             occurrences = matching_threshold.crit_occurrences
            #         elif threshold == "warn" and matching_threshold.warn_threshold:
            #             threshold_limit = float(matching_threshold.warn_threshold)
            #             if matching_threshold.warn_time_seconds:
            #                 delta = dt.timedelta(
            #                     seconds=matching_threshold.warn_time_seconds
            #                 )
            #             message = warn_message
            #             severity = matching_threshold.min_severity
            #             # Amount of time in seconds the threshold can be breached before we actually generate an alert
            #             alert_time = matching_threshold.warn_time_seconds
            #             # Number of times the threshold can be breached before we actually generate an alert
            #             occurrences = matching_threshold.warn_occurrences
            #         else:
            #             continue

            #         operator_ = self.map_operator_to_function(
            #             matching_threshold.operator
            #         )
            #         logging.debug(
            #             f"Comparing: {current_value} {operator_.__name__} {threshold_limit}"
            #         )

            #         is_advanced_threshold = not (not occurrences and not alert_time)
            #         if threshold_limit and operator_(current_value, threshold_limit):
            #             # We've breached the threshold
            #             logging.debug(f"Over {threshold} threshold")
            #             period = (
            #                 f" for {humanize.precisedelta(delta, minimum_unit='minutes')}"
            #                 if alert_time
            #                 else ""
            #             )

            #             message = message.format(
            #                 THRESHOLD=threshold_limit,
            #                 ALERT_TYPE=alert_type,
            #                 PERIOD=f"{period}",
            #             )

            #             # Only allow one output per threshold
            #             suppress_alert = False
            #             if not has_output:
            #                 #  Now check for any occurrence or time based conditions before outputting
            #                 first_occurrence = True
            #                 if (
            #                     matching_threshold.metadata
            #                     and "alert_cache" in matching_threshold.metadata
            #                 ):
            #                     # Loop through each instance of a previous alert to check if the threshold_no matches

            #                     for alert_instance in matching_threshold.metadata[
            #                         "alert_cache"
            #                     ]:
            #                         if (
            #                             alert_instance["threshold_no"] == threshold_id
            #                             and alert_instance["threshold_type"]
            #                             == threshold
            #                         ):
            #                             first_occurrence = False
            #                             # Determine whether to alert or not based on whether we're checking occurrences or time since first breach
            #                             if occurrences:
            #                                 if (
            #                                     alert_instance["occurrences"] + 1
            #                                     <= occurrences
            #                                 ):
            #                                     suppress_alert = True
            #                                 logging.debug(
            #                                     f"Threshold has been breached {alert_instance['occurrences'] + 1} times - Allowed {occurrences} before alerting. {'Suppressing alert.' if suppress_alert else ''}"
            #                                 )
            #                             if alert_time:
            #                                 time_since_breach_started = (
            #                                     time.time()
            #                                     - alert_instance["exceeding_start"]
            #                                 )
            #                                 if time_since_breach_started < alert_time:
            #                                     suppress_alert = True
            #                                 logging.debug(
            #                                     f"Threshold has been breached for {humanize.precisedelta(dt.timedelta(seconds=time_since_breach_started), minimum_unit='minutes')} - Allowed {period} before alerting. {'Suppressing alert.' if suppress_alert else ''}"
            #                                 )
            #                             break
            #                 else:
            #                     logging.debug("No alert cache")
            #                 if first_occurrence:
            #                     # We've not breached before, so check to see if we are breaching now or not
            #                     if occurrences and occurrences > 1:
            #                         logging.debug(
            #                             f"Threshold has been breached for the first time - Allowed {occurrences} before alerting. Suppressing alert."
            #                         )
            #                         suppress_alert = True
            #                     if alert_time:
            #                         logging.debug(
            #                             f"Threshold has been breached for the first time - Allowed {period} before alerting. Suppressing alert."
            #                         )
            #                         suppress_alert = True

            #                 if not suppress_alert:
            #                     result_output = {
            #                         "message": message,
            #                         "alert_key": (alert_id or threshold_id),
            #                         "severity": severity,
            #                         "team": matching_threshold.team,
            #                     }
            #                     logging.debug(f"Adding output line: {result_output}")
            #                     result.result_messages.append(result_output)

            #                     # self.output(
            #                     #     [message],
            #                     #     alert_key=(id or threshold_id),
            #                     #     severity=severity,
            #                     #     team=matching_threshold.team,
            #                     # )
            #                     has_output = True

            #             if is_advanced_threshold:
            #                 # Now we've checked the warn and crit thresholds
            #                 # Write the status to the cache file
            #                 # Append/Update/Create threshold.metadata["alert_cache"]
            #                 # If there's no existing cache entry, create one
            #                 alert_instance = {}
            #                 if "alert_cache" not in matching_threshold.metadata:
            #                     alert_instance = {
            #                         "threshold_type": threshold,
            #                         "threshold_no": threshold_id,
            #                         "exceeding_start": time.time(),
            #                         "occurrences": 1,
            #                     }
            #                     matching_threshold.metadata["alert_cache"] = [
            #                         alert_instance
            #                     ]
            #                 else:
            #                     # Find the existing cache entry and update it
            #                     # or create a new one if there's nothing for this threshold type
            #                     found_cache_entry = False
            #                     for alert_instance_1 in matching_threshold.metadata[
            #                         "alert_cache"
            #                     ]:
            #                         if (
            #                             alert_instance_1["threshold_no"] == threshold_id
            #                             and alert_instance_1["threshold_type"]
            #                             == threshold
            #                         ):
            #                             alert_instance_1["occurrences"] += 1
            #                             alert_instance = alert_instance_1
            #                             found_cache_entry = True
            #                             break

            #                     if not found_cache_entry:
            #                         alert_instance = {
            #                             "threshold_type": threshold,
            #                             "threshold_no": threshold_id,
            #                             "exceeding_start": time.time(),
            #                             "occurrences": 1,
            #                         }
            #                         matching_threshold.metadata["alert_cache"].append(
            #                             alert_instance
            #                         )

            #                 os.makedirs(os.path.dirname(state_file), exist_ok=True)
            #                 with open(state_file, "w", encoding="utf-8") as file_:
            #                     json.dump(
            #                         matching_threshold.metadata["alert_cache"], file_
            #                     )

            #             if not suppress_alert:
            #                 if severity == "Critical":
            #                     rc = 2
            #                 elif rc < 2:
            #                     rc = 1

            #         # If the threshold isn't breached, we need to make sure it's not in the cache
            #         elif is_advanced_threshold:
            #             # Loop through the alert_cache to see if this alert instance exists
            #             # If it does, remove it
            #             cache_needs_update = False
            #             if "alert_cache" in matching_threshold.metadata:
            #                 for alert_instance_2 in matching_threshold.metadata[
            #                     "alert_cache"
            #                 ]:
            #                     if (
            #                         alert_instance_2["threshold_no"] == threshold_id
            #                         and alert_instance_2["threshold_type"] == threshold
            #                     ):
            #                         matching_threshold.metadata["alert_cache"].remove(
            #                             alert_instance_2
            #                         )
            #                         logging.debug("Removed alert instance from cache")
            #                         cache_needs_update = True
            #                         break
            #             # If we made a change, then we need to write the JSON file again
            #             if cache_needs_update:
            #                 with open(state_file, "w", encoding="utf-8") as file_:
            #                     json.dump(
            #                         matching_threshold.metadata["alert_cache"], file_
            #                     )

            # if not has_output:
            #     logging.debug("Threshold is OK")
            #     result_output = {
            #         "message": ok_message,
            #         "alert_key": (alert_id or threshold_id),
            #         "team": matching_threshold.team,
            #     }
            #     logging.debug(f"Adding output line: {result_output}")
            #     result.result_messages.append(result_output)

            #     # self.output([ok_message], alert_key=(id or threshold_id), team=matching_threshold.team)

            # if rc > result.rc:
            #     result.rc = rc

            # threshold_id += 1

        return result

    def _format_messages(
        self, ok_message: str, alert_message: str, warn_message: str, crit_message: str
    ) -> tuple[str, str, str, str]:
        # Ensure we have all args we need
        if not ok_message:
            raise AttributeError(
                "No ok_message passed. Please ensure correct invocation of process_value function"
            )
        if not alert_message and not warn_message and not crit_message:
            raise AttributeError(
                "No alert level message passed. Please ensure correct invocation of process_value function. At least one alert level message is required"
            )

        # Reformat all the messages so that we can use the string format function
        # later on
        ok_message = re.sub(r"::(\w+?)::", r"{\1}", ok_message)
        alert_message = re.sub(r"::(\w+?)::", r"{\1}", alert_message)
        if warn_message:
            re.sub(r"::(\w+?)::", r"{\1}", warn_message)
        if crit_message:
            re.sub(r"::(\w+?)::", r"{\1}", crit_message)

        # Determine what message to use for output
        # Warning level message
        if not warn_message:
            warn_message = alert_message

        # Warning level message
        if not crit_message:
            crit_message = alert_message

        return ok_message, alert_message, warn_message, crit_message

    def get_thresholds(
        self, alert_id: int = None, alert_type: str = None
    ) -> list[Threshold]:
        """Get a list of thresholds that match the given alert_id or alert_type.

        Args:
            alert_id (str, optional): The alert ID to match. Defaults to None.
            alert_type (str, optional): The alert type to match. Defaults to None.

        Returns:
            list[Threshold]: A list of thresholds that match the given alert_id or alert_type.
        """
        matching_thresholds = []
        default_threshold = None

        if alert_id:
            for threshold in self.thresholds:
                # If we found a threshold for this ID then save it and break
                if threshold.id == alert_id:
                    matching_thresholds.append(threshold)
                    break

                # If we havent found a specific threshold, but we found the default one
                # save it, incase we need dont find a specific one at all
                if not threshold.id:
                    default_threshold = threshold

            # If we didn't find a specific threshold, then we need to use the default
            if not matching_thresholds:
                matching_thresholds.append(default_threshold)

        elif alert_type:
            for threshold in self.thresholds:
                if (
                    threshold.metadata
                    and "alert_type" in threshold.metadata
                    and threshold.metadata["alert_type"] == alert_type
                ):
                    matching_thresholds.append(threshold)
        else:
            matching_thresholds = self.thresholds

        return matching_thresholds

    def process_output_and_rc(
        self,
        threshold_result: ThresholdResult,
        result_message_good: str,
        result_message_alert: str,
    ) -> tuple[str, int]:
        """Process the output and return the final message and return code.

        Args:
            threshold_result (ThresholdResult): The result of the threshold check.
            result_message_good (str): The message to return if the threshold is OK.
            result_message_alert (str): The message to return if the threshold is breached.

        Returns:
            tuple[str, int]: The final message and return code.
        """
        rc = 0
        result_message_final = result_message_good
        if threshold_result:
            for message in threshold_result.result_messages:
                self.output(
                    [message["message"]],
                    alert_key=message["alert_key"],
                    team=message["team"],
                    severity=(message["severity"] if "severity" in message else None),
                )

            if threshold_result.rc != 0 and rc < threshold_result.rc:
                rc = threshold_result.rc
                result_message_final = result_message_alert

        return result_message_final, rc
