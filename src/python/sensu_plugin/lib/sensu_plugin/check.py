#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pylint: disable=no-member
"""This is the base class for all Sensu Checks to build from."""


import re
from dataclasses import dataclass

from sensu_plugin.check_result import CheckResultMetadata
from sensu_plugin.plugin import SensuPlugin
from sensu_plugin.threshold import Threshold, ThresholdResult


@dataclass
class SensuPluginCheck(SensuPlugin):
    """Class that inherits from SensuPlugin."""

    thresholds: list[Threshold]

    def __init__(self, thresholds: list[Threshold] | None = None, autorun: bool = True):
        """Initialise the SensuPluginCheck class.

        Args:
            thresholds (list[Threshold]): List of thresholds to be used by the plugin
            autorun (bool): Whether the plugin should be run automatically. This can
                be useful for automated testing

        Returns:
            SensuPluginCheck: Instance of the SensuPluginCheck class
        """
        self.thresholds = thresholds or []

        SensuPlugin.__init__(self, autorun)

    def check_name(self, name: str | None = None) -> str:
        """Check the plugin name and set it accordingly.

        Use name if specified, class name if not set.

        Args:
            name (str): Name of the plugin

        Returns:
            str: Name of the plugin
        """
        if name:
            self.plugin_info["check_name"] = name

        if self.plugin_info["check_name"] is not None:
            return str(self.plugin_info["check_name"])

        return self.__class__.__name__

    def message(self, *m: str) -> None:
        """
        Set the message to be output by the plugin.

        Args:
            m (str): Message to be output by the plugin
        """
        self.plugin_info["message"] = m

    def output(  # type: ignore[override]  # pylint: disable=too-many-arguments
        self,
        args: list[str] | None = None,
        alert_key: str | None = None,
        severity: str | None = None,
        team: str | None = None,
        source: str | None = None,
    ) -> None:
        """Generate and output the result of the plugin.

        Correctly format the output into the format that Sensu expects.

        This function is called for every line of output generated by the check (but not metrics).

        A pipe is used as a delimiter between the format required by Sensu, and any additional metadata
        that can be used by handlers. e.g the alert key, severity, team and alert source.

        There is no return value from this function, as it prints the output directly to stdout.

        Args:
            args (list): List of lines to be output by the plugin. Normally this will contain
                a single string
            alert_key (str): Alert key to be used by check handlers
            severity (str): Severity of the alert (Minor, Major, Critical). Used when you need more than just WARN and CRIT
            team (str): Team responsible for the alert
            source (str): Source of the alert. If the alert is being generated on a proxy
                host, this should be the hostname of the host that generated the alert
        """
        msg = ""
        # If there's more than 1 string passed in, then we will join them together
        # This will ensure that stack traces for example only output a single line
        if args is not None and not (len(args) == 1 and args[0] is None):
            msg = f": {' '.join(str(message) for message in args)}"
        else:
            msg = self.plugin_info["message"]

        # Default to OK
        self.plugin_info["status"] = "OK"
        if severity and not re.match(r"^Minor", severity, re.IGNORECASE):
            self.plugin_info["status"] = "CRITICAL"
        elif severity:
            self.plugin_info["status"] = "WARN"

        alert_key = f"KEY:{alert_key} " if alert_key else ""
        severity_msg = f"SEV:{severity} " if severity else ""
        team_msg = f"TEAM:{team} " if team else ""
        source_msg = f"SOURCE:{source} " if source else ""

        end_text = (
            f" | {alert_key}{severity_msg}{team_msg}{source_msg}"
            if (alert_key or severity_msg or team_msg or source_msg)
            else ""
        )
        output_text = f"{self.check_name()} {self.plugin_info['status']}{msg}{end_text}"

        print(output_text)

    def return_final_output(self, rc: int, result_message: str) -> None:
        """Handle the final output message of the plugin and call the exit function with the correct return code.

        This function is called once at the end of the plugin execution.

        The ok, warning, critical functions are dynamically added to the class by the SensuPlugin (__make_dynamic)

        Args:
            rc (int): Return code to be used by the plugin
            result_message (str): Message to be output by the plugin
        """
        if rc == 0:
            self.ok(result_message, exit=True)  # type: ignore[attr-defined]
        elif rc == 1:
            self.warning(result_message, exit=True)  # type: ignore[attr-defined]
        elif rc == 2:
            self.critical(result_message, exit=True)  # type: ignore[attr-defined]
        else:
            self.unknown("Unknown state returned", exit=True)  # type: ignore[attr-defined]

    def process_value(  # pylint: disable=too-many-arguments
        self,
        alert_id: str | None,
        current_value: str | int | float,
        ok_message: str,
        alert_message: str,
        warn_message: str | None = None,
        crit_message: str | None = None,
        alert_type: str | None = None,
    ) -> ThresholdResult | None:
        """Process threshold values and return the appropriate message and exit code.

        This function does the body of the work for a SensuPluginCheck. It takes the current value
        and compares it against the thresholds defined in the thresholds list.

        If the current value is outside of the thresholds, then the appropriate message is returned
        and the appropriate exit code is set.

        Templated messages:

        The templated messages are used to allow the user to define the output for each threshold as
        it is checked. The templated values are surrounded by double colons (::) and are replaced with
        the appropriate values when the message is returned.

        The following templated values are available:
            THRESHOLD: The threshold value that was breached
            ALERT_TYPE: The type of alert that was breached (e.g. %, cores, MB)
            PERIOD: The period of time that the threshold breached before triggering

        Args:
            alert_id (str | None): The ID of the alert. This is used to identify the alert in the thresholds list
            current_value (str | int): The current value to be checked against the thresholds
            ok_message (str): The message to be returned if the current value is within the thresholds
            alert_message (str): The default templated message to return when the threshold is breached. This is used if no warn_message or crit_message is passed
            warn_message (str | None): The templated message to return when the warn threshold is breached
            crit_message (str | None): The templated message to return when the crit threshold is breached
            alert_type (str | None): The type of alert that is being checked. This is used in the templated messages
        """
        # This will be the final object we return. Give it a default of 0 (OK) for now

        ok_message, alert_message, warn_message, crit_message = self._format_messages(
            ok_message, alert_message, warn_message, crit_message
        )

        self.logger.debug(
            f"Checking thresholds for key: {alert_id} - With current value of {current_value}"
        )

        # Look for a threshold with a matching ID
        matching_thresholds = self.get_thresholds(alert_id, alert_type)

        # Create a CheckResultMetadata object to store the alert messages, alert id and check name
        check_result_metadata = CheckResultMetadata(
            ok_message,
            warn_message,
            crit_message,
            self.check_name(),
            alert_id,
            alert_type,
            self.SENSU_CACHE_DIR,
        )

        result = None

        # Evaluate each threshold and aggregate the results
        threshold_id = 1
        for matching_threshold in matching_thresholds:
            self.logger.debug(f"Using threshold: {matching_threshold}")
            threshold_result = matching_threshold.evaluate_threshold(
                threshold_id,
                current_value,
                check_result_metadata,
            )
            threshold_id += 1

            # If result is none, then use threshold_result, otherwise, check the threshold_result rc value, if it's higher, then append the result_messages to the existing result, and set the rc to that value
            if result is None:
                result = threshold_result
            else:
                if threshold_result and threshold_result.rc > result.rc:  # type: ignore[unreachable]
                    result.rc = threshold_result.rc

                if threshold_result:
                    result.result_messages += threshold_result.result_messages

        return result

    def _format_messages(
        self,
        ok_message: str,
        alert_message: str,
        warn_message: str | None,
        crit_message: str | None,
    ) -> tuple[str, str, str, str]:
        # Ensure we have all args we need
        if not ok_message:
            raise AttributeError(
                "No ok_message passed. Please ensure correct invocation of process_value function"
            )
        if not alert_message and not warn_message and not crit_message:
            raise AttributeError(
                "No alert level message passed. Please ensure correct invocation of process_value function. At least one alert level message is required"
            )

        # Reformat all the messages so that we can use the string format function
        # later on
        ok_message = re.sub(r"::(\w+?)::", r"{\1}", ok_message)
        alert_message = re.sub(r"::(\w+?)::", r"{\1}", alert_message)
        if warn_message:
            re.sub(r"::(\w+?)::", r"{\1}", warn_message)
        if crit_message:
            re.sub(r"::(\w+?)::", r"{\1}", crit_message)

        # Determine what message to use for output
        # Warning level message
        if not warn_message:
            warn_message = alert_message

        # Warning level message
        if not crit_message:
            crit_message = alert_message

        return ok_message, alert_message, warn_message, crit_message

    def get_thresholds(
        self, alert_id: str | None = None, alert_type: str | None = None
    ) -> list[Threshold]:
        """Get a list of thresholds that match the given alert_id or alert_type.

        Args:
            alert_id (str, optional): The alert ID to match. Defaults to None.
            alert_type (str, optional): The alert type to match. Defaults to None.

        Returns:
            list[Threshold]: A list of thresholds that match the given alert_id or alert_type.
        """
        matching_thresholds = []
        default_threshold = None

        if alert_id:
            for threshold in self.thresholds:
                # If we found a threshold for this ID then save it and break
                if threshold.id == alert_id:
                    matching_thresholds.append(threshold)
                    break

                # If we havent found a specific threshold, but we found the default one
                # save it, incase we need dont find a specific one at all
                if not threshold.id:
                    default_threshold = threshold

            # If we didn't find a specific threshold, then we need to use the default
            if not matching_thresholds and default_threshold:
                matching_thresholds.append(default_threshold)

        elif alert_type:
            for threshold in self.thresholds:
                if (
                    threshold.metadata
                    and "alert_type" in threshold.metadata
                    and threshold.metadata["alert_type"] == alert_type
                ):
                    matching_thresholds.append(threshold)
        else:
            matching_thresholds = self.thresholds

        return matching_thresholds

    def process_output_and_rc(
        self,
        threshold_result: ThresholdResult | None,
        result_message_good: str,
        result_message_alert: str,
    ) -> tuple[str, int]:
        """Process the output and return the final message and return code.

        Args:
            threshold_result (ThresholdResult): The result of the threshold check.
            result_message_good (str): The message to return if the threshold is OK.
            result_message_alert (str): The message to return if the threshold is breached.

        Returns:
            tuple[str, int]: The final message and return code.
        """
        rc = 0
        result_message_final = result_message_good
        if threshold_result:
            for message in threshold_result.result_messages:
                self.output(
                    [message["message"]],
                    alert_key=message["alert_key"],
                    team=message["team"],
                    severity=(message["severity"] if "severity" in message else None),
                )

            if threshold_result.rc != 0 and rc < threshold_result.rc:
                rc = threshold_result.rc
                result_message_final = result_message_alert

        return result_message_final, rc
